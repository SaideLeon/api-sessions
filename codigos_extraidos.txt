ARQUIVOS JAVASCRIPT
================================================================================
Diretório base: ./src
========================================

================================================================================
Arquivo: ./src/server.js
================================================================================

import 'express-async-errors';
import express from 'express';
import cors from 'cors';
import morgan from 'morgan';
import helmet from 'helmet';
import compression from 'compression';
import { config } from 'dotenv';
import { PrismaClient } from '@prisma/client';
import { fileURLToPath } from 'url';
import { dirname, join } from 'path';
import http from 'http';
import { Server as SocketServer } from 'socket.io';
import winston from 'winston';
import { rateLimit } from 'express-rate-limit';

// Rotas
import userRoutes from './routes/userRoutes.mjs';
import { createNewSession, getUserSessions, getQrCode } from './routes/sessionsRoutes.mjs';
import messageRoutes from './routes/messageRoutes.mjs';
import vendorRoutes from './routes/vendorRoutes.mjs';
import sellerRoutes from './routes/sellerRoutes.mjs';
import authRoutes from './routes/authRoutes.mjs';

// Middlewares
import { errorHandler, notFound, handleUncaughtExceptions } from './middlewares/error.mjs';
import { limiter } from './middlewares/rateLimit.mjs';
import initSessions from './utils/initSession.mjs'; 

// Configurações
config(); // Carrega variáveis de ambiente
const prisma = new PrismaClient();
const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);

// Configuração do Logger
const logger = winston.createLogger({
  level: process.env.LOG_LEVEL || 'info',
  format: winston.format.combine(
    winston.format.timestamp(),
    winston.format.json()
  ),
  transports: [
    new winston.transports.Console({
      format: winston.format.combine(
        winston.format.colorize(),
        winston.format.simple()
      )
    }),
    new winston.transports.File({ filename: 'error.log', level: 'error' }),
    new winston.transports.File({ filename: 'combined.log' })
  ]
});

// Tratamento de exceções não capturadas
handleUncaughtExceptions();

class App {
  constructor() {
    this.app = express();
    this.server = null;
    this.io = null;
    this.sessions = new Map();
    this.isDevelopment = process.env.NODE_ENV === 'development';
    this.prisma = prisma;

    // Inicialização
    this.validateEnvironment();
    this.createServer();
    this.setupWebSocket();
    this.middlewares();
    this.routes();
    this.errorHandling();
    this.initAllSessions();
  }

  validateEnvironment() {
    const requiredEnvVars = [
      'NODE_ENV',
      'PORT',
      'DATABASE_URL',
      'JWT_SECRET',
      'JWT_EXPIRES_IN',
      'CORS_ORIGIN',
      'GROQ_API_KEY',
      'GROQ_MODEL'
    ];

    for (const envVar of requiredEnvVars) {
      if (!process.env[envVar]) {
        logger.error(`Missing required environment variable: ${envVar}`);
        process.exit(1);
      }
    }
  }

  createServer() {
    this.server = http.createServer(this.app);
    return this.server;
  }

  setupWebSocket() {
    this.io = new SocketServer(this.server, {
      cors: {
        origin: process.env.CORS_ORIGIN || '*',
        methods: ['GET', 'POST'],
        credentials: true
      },
      pingTimeout: 60000,
      pingInterval: 25000
    });
  

    this.io.on('connection', (socket) => {
      logger.info(`WebSocket client connected: ${socket.id}`);

      socket.on('disconnect', () => {
        logger.info(`WebSocket client disconnected: ${socket.id}`);
      });

      socket.on('error', (error) => {
        logger.error(`WebSocket error for client ${socket.id}:`, error);
      });
    });
  }

  middlewares() {
    // Configuração para proxies
    this.app.set('trust proxy', 1);

    // Segurança
    this.app.use(helmet());
    this.app.use(cors({
      origin: process.env.CORS_ORIGIN || '*',
      methods: ['GET', 'POST', 'PUT', 'DELETE', 'PATCH', 'OPTIONS'],
      allowedHeaders: ['Content-Type', 'Authorization'],
      credentials: true,
      maxAge: 86400
    }));
    
    // Rate limiting
    const apiLimiter = rateLimit({
      windowMs: 15 * 60 * 1000,
      max: 100,
      standardHeaders: true,
      legacyHeaders: false,
      handler: (req, res) => {
        logger.warn(`Rate limit exceeded for IP: ${req.ip}`);
        res.status(429).json({
          status: 'error',
          message: 'Too many requests, please try again later.'
        });
      }
    });
    this.app.use('/api/', apiLimiter);

    // Body parsing
    this.app.use(express.json({ limit: '10kb' }));
    this.app.use(express.urlencoded({ extended: true, limit: '10kb' }));

    // Compressão
    this.app.use(compression());

    // Logging
    if (this.isDevelopment) {
      this.app.use(morgan('dev'));
    } else {
      this.app.use(morgan('combined', {
        stream: { write: message => logger.info(message.trim()) }
      }));
    }

    // Arquivos estáticos
    this.app.use('/public', express.static(join(__dirname, '../public')));

    // Timestamp da requisição
    this.app.use((req, res, next) => {
      req.requestTime = new Date().toISOString();
      req.logger = logger;
      next();
    });
  }
  
  initAllSessions() {
  	initSessions(this.io, this.sessions);
  }

  routes() {
    const apiV1 = '/api/v1';

    // Health check
    this.app.get(`${apiV1}/health`, (req, res) => {
      res.status(200).json({
        status: 'success',
        message: 'Server is running',
        timestamp: req.requestTime,
        environment: process.env.NODE_ENV,
        version: process.env.npm_package_version || '19.0.0',
        websocket: this.io ? 'enabled' : 'disabled'
      });
    });

    // API routes
    this.app.use(`${apiV1}/users`, userRoutes);
    this.app.use(`${apiV1}/auth`, authRoutes);
    
    // Corrigindo a passagem do objeto sessions para as rotas
    this.app.use(`${apiV1}/sessions`, createNewSession(this.io, this.sessions));
    this.app.use(`${apiV1}/sessions`, getQrCode(this.sessions)); // Fixed: Passing this.sessions
    this.app.use(`${apiV1}/sessions`, getUserSessions);
    
    this.app.use(`${apiV1}/messages`, messageRoutes);
    this.app.use(`${apiV1}/vendors`, vendorRoutes);
    this.app.use(`${apiV1}/sellers`, sellerRoutes);

    // Handle undefined routes
    this.app.use(notFound);
  }

  errorHandling() {
    this.app.use(errorHandler);
  }

  async connectDatabase() {
    try {
      await this.prisma.$connect();
      logger.info('📦 Database connected successfully');
    } catch (error) {
      logger.error('❌ Database connection error:', error);
      throw error;
    }
  }

  async start() {
    try {
      await this.connectDatabase();
      
      const PORT = process.env.PORT || 3000;

      return new Promise((resolve) => {
        this.server.listen(PORT, () => {
          logger.info(`
🚀 Server running in ${process.env.NODE_ENV} mode on port ${PORT}
⭐️ API URL: http://localhost:${PORT}${process.env.API_PREFIX || '/api/v1'}
📝 API Docs: http://localhost:${PORT}/api-docs
🔌 WebSocket enabled
          `);
          resolve(this.server);
        });
      });
    } catch (error) {
      logger.error('Failed to start server:', error);
      throw error;
    }
  }

  async stop() {
    if (this.io) {
      this.io.close();
    }
    
    if (this.server) {
      return new Promise((resolve) => {
        this.server.close(async () => {
          await this.prisma.$disconnect();
          logger.info('Server, WebSocket, and database connections closed');
          resolve();
        });
      });
    }
  }

  getServer() {
    return this.server;
  }

  getApp() {
    return this.app;
  }

  getIO() {
    return this.io;
  }

  getSessions() {
    return this.sessions;
  }
}

// Criação da instância
const appInstance = new App();

// Inicialização do servidor
const startServer = async () => {
  try {
    await appInstance.start();
  } catch (error) {
    logger.error('Failed to start server:', error);
    process.exit(1);
  }
};

startServer();

// Tratamento de erros não capturados
process.on('unhandledRejection', async (err) => {
  logger.error('UNHANDLED REJECTION! 💥 Shutting down...', err);
  await appInstance.stop();
  process.exit(1);
});

// Graceful shutdown
process.on('SIGTERM', async () => {
  logger.info('👋 SIGTERM RECEIVED. Shutting down gracefully');
  await appInstance.stop();
  process.exit(0);
});

// Tratamento de exceções não capturadas
process.on('uncaughtException', async (err) => {
  logger.error('UNCAUGHT EXCEPTION! 💥 Shutting down...', err);
  await appInstance.stop();
  process.exit(1);
});

export default appInstance.getApp();

================================================================================
Arquivo: ./src/cerebro.mjs
================================================================================

import fs from 'fs';
import dotenv from 'dotenv';
import path from 'path';
import { ChatGoogleGenerativeAI } from '@langchain/google-genai';
import temp from 'temp'; 
import { Groq } from 'groq-sdk';
import personAI from "./core/person.mjs";

dotenv.config(); 

temp.track();
const visionModel = new ChatGoogleGenerativeAI({
    model: "gemini-1.5-flash",
    maxOutputTokens: 2048,
});

const groq = new Groq({ apiKey: process.env.GROQ_API_KEY });
const groqModel = process.env.GROQ_MODEL;

class Cerebro {
    constructor() {
        if (!groqModel) {
            throw new Error("Modelo GROQ não configurado. Verifique GROQ_MODEL no arquivo .env.");
        }
    }

    async gerarRespostaIA(userId, mensagemUsuario, sessionId) {
        try {
        	const respostaIA = await personAI(sessionid=sessionId, userPrompt=mensagemUsuario, number=userId);
         
            return respostaIA;
        } catch (error) {
            console.error("Erro ao gerar resposta da IA:", error.message);
            return "Houve um erro ao tentar gerar a resposta.";
        }
    }

    async transcreverAudio(userId, mediaData, sessionId) {
        let tempFilePath;
        try {
            tempFilePath = temp.path({ suffix: ".mp3" });
            fs.writeFileSync(tempFilePath, mediaData.data.split(",")[1], { encoding: "base64" });

            const transcription = await groq.audio.transcriptions.create({
                file: fs.createReadStream(tempFilePath),
                model: "whisper-large-v3-turbo",
            });

            const transcricao = transcription.text || "Não consegui transcrever o áudio.";
            return await this.gerarRespostaIA(userId, transcricao, sessionId);
        } catch (error) {
            console.error("Erro ao transcrever o áudio:", error.message);
            return "Desculpe, houve um erro ao processar o áudio.";
        } finally {
            if (tempFilePath && fs.existsSync(tempFilePath)) {
                fs.unlinkSync(tempFilePath);
            }
        }
    }

    async gerarRespostaImagem(userId, mediaData) {
        try {
            const input = [
                {
                    role: "human",
                    content: [
                        { type: "text", text: "Analise a imagem fornecida e descreva-a detalhadamente." },
                        { type: "image_url", image_url: mediaData.data },
                    ],
                },
            ];

            const res = await visionModel.invoke(input);
            const respostaIA = res?.content || "Não consegui analisar a imagem.";

            this.atualizarHistorico(userId, { role: "user", content: "[Imagem recebida do usuário]" });
            this.atualizarHistorico(userId, { role: "assistant", content: respostaIA });

            return respostaIA;
        } catch (error) {
            console.error("Erro ao processar a imagem:", error.message);
            return "Desculpe, houve um erro ao analisar a imagem.";
        }
    }
}

export default Cerebro;


================================================================================
Arquivo: ./src/config/database.js
================================================================================



================================================================================
Arquivo: ./src/config/env.js
================================================================================

// src/config/env.js
import { config } from 'dotenv';

config();

export default {
  // App
  PORT: process.env.PORT || 3000,
  NODE_ENV: process.env.NODE_ENV || 'development',
  API_VERSION: process.env.API_VERSION || 'v1',
  
  // Database
  DATABASE_URL: process.env.DATABASE_URL,
  
  // JWT
  JWT_SECRET: process.env.JWT_SECRET,
  JWT_EXPIRES_IN: process.env.JWT_EXPIRES_IN || '24h',
  
  // Cors
  CORS_ORIGIN: process.env.CORS_ORIGIN || '*',
  
  // Rate Limiting
  RATE_LIMIT_WINDOW: process.env.RATE_LIMIT_WINDOW || 15 * 60 * 1000, // 15 minutes
  RATE_LIMIT_MAX: process.env.RATE_LIMIT_MAX || 100,
  
  // Security
  BCRYPT_ROUNDS: process.env.BCRYPT_ROUNDS || 10,
  
  // Logging
  LOG_LEVEL: process.env.LOG_LEVEL || 'debug',
  
  // Cache
  CACHE_TTL: process.env.CACHE_TTL || 60 * 60, // 1 hour
};

================================================================================
Arquivo: ./src/controllers/userController.mjs
================================================================================

// src/controllers/userController.mjs
import UserService from '../services/userService.mjs';
import AppError from '../utils/AppError.mjs';

class UserController {
  constructor() {
    this.userService = new UserService();
    // Bind all methods to preserve 'this' context
    this.create = this.create.bind(this);
    this.find = this.find.bind(this);
    this.findOne = this.findOne.bind(this);
    this.update = this.update.bind(this);
    this.delete = this.delete.bind(this);
  }

  async create(req, res, next) {
    try {
      const user = await this.userService.create(req.body);
      return res.status(201).json({
        status: 'success',
        message: 'User created successfully',
        data: user,
      });
    } catch (err) {
      next(err);
    }
  }

  async find(req, res, next) {
    try {
      const users = await this.userService.findAll();
      return res.status(200).json({
        status: 'success',
        data: users,
      });
    } catch (err) {
      next(err);
    }
  }

  async findOne(req, res, next) {
    try {
      const { id } = req.params;
      const user = await this.userService.findById(id);
      return res.status(200).json({
        status: 'success',
        data: user,
      });
    } catch (err) {
      next(err);
    }
  }

  async update(req, res, next) {
    try {
      const { id } = req.params;
      const updatedUser = await this.userService.update(id, req.body);
      return res.status(200).json({
        status: 'success',
        message: 'User updated successfully',
        data: updatedUser,
      });
    } catch (err) {
      next(err);
    }
  }

  async delete(req, res, next) {
    try {
      const { id } = req.params;
      await this.userService.delete(id);
      return res.status(204).send();
    } catch (err) {
      next(err);
    }
  }
}

export default UserController;

================================================================================
Arquivo: ./src/controllers/sessionController.mjs
================================================================================

// src/controllers/sessionController.mjs
import { PrismaClient } from '@prisma/client';
import AppError from '../utils/AppError.mjs';
import { v4 as uuidv4 } from 'uuid';

class SessionController {
  constructor() {
    this.prisma = new PrismaClient();
  }

  async create(req, res, next) {
    try {
      const { userId, title, type = 'regular' } = req.body;

      // Gerar um ID único para a sessão
      const sessionId = uuidv4();

      // Verificar se o usuário existe
      const user = await this.prisma.user.findUnique({
        where: { id: Number(userId) }
      });

      if (!user) {
        throw new AppError('User not found', 404);
      }

      // Criar a sessão
      const session = await this.prisma.session.create({
        data: {
          sessionId,
          title,
          type,
          status: 'active',
          userId: Number(userId)
        },
        include: {
          user: {
            select: {
              id: true,
              username: true,
              email: true
            }
          }
        }
      });

      return res.status(201).json({
        status: 'success',
        message: 'Session created successfully',
        data: session
      });
    } catch (error) {
      next(error);
    }
  }

  async findAll(req, res, next) {
    try {
      const sessions = await this.prisma.session.findMany({
        include: {
          user: {
            select: {
              id: true,
              username: true,
              email: true
            }
          },
          messages: true
        }
      });

      return res.status(200).json({
        status: 'success',
        data: sessions
      });
    } catch (error) {
      next(error);
    }
  }

  async findOne(req, res, next) {
    try {
      const { sessionId } = req.params;

      const session = await this.prisma.session.findUnique({
        where: { sessionId },
        include: {
          user: {
            select: {
              id: true,
              username: true,
              email: true
            }
          },
          messages: true
        }
      });

      if (!session) {
        throw new AppError('Session not found', 404);
      }

      return res.status(200).json({
        status: 'success',
        data: session
      });
    } catch (error) {
      next(error);
    }
  }

  async update(req, res, next) {
    try {
      const { sessionId } = req.params;
      const { title, status } = req.body;

      const session = await this.prisma.session.update({
        where: { sessionId },
        data: {
          title,
          status
        },
        include: {
          user: {
            select: {
              id: true,
              username: true,
              email: true
            }
          }
        }
      });

      return res.status(200).json({
        status: 'success',
        message: 'Session updated successfully',
        data: session
      });
    } catch (error) {
      next(error);
    }
  }

  async delete(req, res, next) {
    try {
      const { sessionId } = req.params;

      await this.prisma.session.delete({
        where: { sessionId }
      });

      return res.status(204).send();
    } catch (error) {
      next(error);
    }
  }
}

export default SessionController;



================================================================================
Arquivo: ./src/controllers/sellerController.mjs
================================================================================

// src/controllers/sellerController.mjs
import { PrismaClient } from '@prisma/client';
import AppError from '../utils/AppError.mjs';

class SellerController {
  constructor() {
    this.prisma = new PrismaClient();
  }

  async create(req, res, next) {
    try {
      const { sessionId, sellerName, product, description, benefits, image } = req.body;

      // Verificar se a sessão existe
      const session = await this.prisma.session.findUnique({
        where: { sessionId }
      });

      if (!session) {
        throw new AppError('Session not found', 404);
      }

      // Verificar se já existe um vendedor com o mesmo nome na sessão
      const existingSeller = await this.prisma.seller.findUnique({
        where: {
          sessionId_sellerName: {
            sessionId,
            sellerName
          }
        }
      });

      if (existingSeller) {
        throw new AppError('Seller already exists in this session', 400);
      }

      // Criar o vendedor
      const seller = await this.prisma.seller.create({
        data: {
          sessionId,
          sellerName,
          product,
          description,
          benefits,
          image
        },
        include: {
          session: {
            select: {
              sessionId: true,
              title: true,
              type: true,
              status: true
            }
          }
        }
      });

      return res.status(201).json({
        status: 'success',
        message: 'Seller created successfully',
        data: seller
      });
    } catch (error) {
      next(error);
    }
  }

  async findAll(req, res, next) {
    try {
      const { sessionId } = req.query;
      
      let whereClause = {};
      if (sessionId) {
        whereClause.sessionId = sessionId;
      }

      const sellers = await this.prisma.seller.findMany({
        where: whereClause,
        include: {
          session: {
            select: {
              sessionId: true,
              title: true,
              type: true,
              status: true
            }
          }
        },
        orderBy: {
          createdAt: 'desc'
        }
      });

      return res.status(200).json({
        status: 'success',
        results: sellers.length,
        data: sellers
      });
    } catch (error) {
      next(error);
    }
  }

  async findOne(req, res, next) {
    try {
      const { id } = req.params;

      const seller = await this.prisma.seller.findUnique({
        where: { id: Number(id) },
        include: {
          session: {
            select: {
              sessionId: true,
              title: true,
              type: true,
              status: true
            }
          }
        }
      });

      if (!seller) {
        throw new AppError('Seller not found', 404);
      }

      return res.status(200).json({
        status: 'success',
        data: seller
      });
    } catch (error) {
      next(error);
    }
  }

  async update(req, res, next) {
    try {
      const { id } = req.params;
      const updateData = req.body;

      const existingSeller = await this.prisma.seller.findUnique({
        where: { id: Number(id) }
      });

      if (!existingSeller) {
        throw new AppError('Seller not found', 404);
      }

      const seller = await this.prisma.seller.update({
        where: { id: Number(id) },
        data: updateData,
        include: {
          session: {
            select: {
              sessionId: true,
              title: true,
              type: true,
              status: true
            }
          }
        }
      });

      return res.status(200).json({
        status: 'success',
        message: 'Seller updated successfully',
        data: seller
      });
    } catch (error) {
      next(error);
    }
  }

  async delete(req, res, next) {
    try {
      const { id } = req.params;

      const seller = await this.prisma.seller.findUnique({
        where: { id: Number(id) }
      });

      if (!seller) {
        throw new AppError('Seller not found', 404);
      }

      await this.prisma.seller.delete({
        where: { id: Number(id) }
      });

      return res.status(204).send();
    } catch (error) {
      next(error);
    }
  }

  async findBySession(req, res, next) {
    try {
      const { sessionId } = req.params;

      const session = await this.prisma.session.findUnique({
        where: { sessionId }
      });

      if (!session) {
        throw new AppError('Session not found', 404);
      }

      const sellers = await this.prisma.seller.findMany({
        where: { sessionId },
        include: {
          session: {
            select: {
              sessionId: true,
              title: true,
              type: true,
              status: true
            }
          }
        },
        orderBy: {
          createdAt: 'desc'
        }
      });

      return res.status(200).json({
        status: 'success',
        results: sellers.length,
        data: sellers
      });
    } catch (error) {
      next(error);
    }
  }
}

export default SellerController;

================================================================================
Arquivo: ./src/controllers/vendorController.mjs
================================================================================

// src/controllers/vendorController.mjs
import { PrismaClient } from '@prisma/client';
import AppError from '../utils/AppError.mjs';

class VendorController {
  constructor() {
    this.prisma = new PrismaClient();
  }

  async create(req, res, next) {
    try {
      const { sessionId, phoneNumber, vendorName } = req.body;

      // Verificar se a sessão existe
      const session = await this.prisma.session.findUnique({
        where: { sessionId }
      });

      if (!session) {
        throw new AppError('Session not found', 404);
      }

      // Verificar se já existe um vendor para esta sessão
      const existingVendor = await this.prisma.vendor.findUnique({
        where: { sessionId }
      });

      if (existingVendor) {
        throw new AppError('A vendor already exists for this session', 400);
      }

      const vendor = await this.prisma.vendor.create({
        data: {
          sessionId,
          phoneNumber,
          vendorName
        },
        include: {
          session: {
            select: {
              sessionId: true,
              title: true,
              status: true
            }
          }
        }
      });

      return res.status(201).json({
        status: 'success',
        message: 'Vendor created successfully',
        data: vendor
      });
    } catch (error) {
      next(error);
    }
  }

  async findAll(req, res, next) {
    try {
      const vendors = await this.prisma.vendor.findMany({
        include: {
          session: {
            select: {
              sessionId: true,
              title: true,
              status: true
            }
          }
        }
      });

      return res.status(200).json({
        status: 'success',
        results: vendors.length,
        data: vendors
      });
    } catch (error) {
      next(error);
    }
  }

  async findOne(req, res, next) {
    try {
      const { id } = req.params;

      const vendor = await this.prisma.vendor.findUnique({
        where: { id: Number(id) },
        include: {
          session: {
            select: {
              sessionId: true,
              title: true,
              status: true
            }
          }
        }
      });

      if (!vendor) {
        throw new AppError('Vendor not found', 404);
      }

      return res.status(200).json({
        status: 'success',
        data: vendor
      });
    } catch (error) {
      next(error);
    }
  }

  async update(req, res, next) {
    try {
      const { id } = req.params;
      const { vendorName, phoneNumber } = req.body;

      const vendor = await this.prisma.vendor.update({
        where: { id: Number(id) },
        data: {
          vendorName,
          phoneNumber
        },
        include: {
          session: {
            select: {
              sessionId: true,
              title: true,
              status: true
            }
          }
        }
      });

      return res.status(200).json({
        status: 'success',
        message: 'Vendor updated successfully',
        data: vendor
      });
    } catch (error) {
      next(error);
    }
  }

  async delete(req, res, next) {
    try {
      const { id } = req.params;

      await this.prisma.vendor.delete({
        where: { id: Number(id) }
      });

      return res.status(204).send();
    } catch (error) {
      next(error);
    }
  }
}
export default VendorController;




================================================================================
Arquivo: ./src/controllers/messageController.mjs
================================================================================

// src/controllers/messageController.mjs
import { PrismaClient } from '@prisma/client';
import AppError from '../utils/AppError.mjs';

class MessageController {
  constructor() {
    this.prisma = new PrismaClient();
  }

  async create(req, res, next) {
    try {
      const { sessionId, sender, content, phoneNumber, mediaUrl } = req.body;

      // Verificar se a sessão existe
      const session = await this.prisma.session.findUnique({
        where: { sessionId }
      });

      if (!session) {
        throw new AppError('Session not found', 404);
      }

      const message = await this.prisma.message.create({
        data: {
          sessionId,
          sender,
          content,
          phoneNumber,
          mediaUrl
        },
        include: {
          session: {
            select: {
              sessionId: true,
              title: true,
              status: true
            }
          }
        }
      });

      return res.status(201).json({
        status: 'success',
        message: 'Message created successfully',
        data: message
      });
    } catch (error) {
      next(error);
    }
  }

  async findAll(req, res, next) {
    try {
      const { sessionId } = req.query;
      
      const whereClause = sessionId ? { sessionId } : {};

      const messages = await this.prisma.message.findMany({
        where: whereClause,
        include: {
          session: {
            select: {
              sessionId: true,
              title: true,
              status: true
            }
          }
        },
        orderBy: {
          createdAt: 'asc'
        }
      });

      return res.status(200).json({
        status: 'success',
        results: messages.length,
        data: messages
      });
    } catch (error) {
      next(error);
    }
  }

  async findOne(req, res, next) {
    try {
      const { id } = req.params;

      const message = await this.prisma.message.findUnique({
        where: { id: Number(id) },
        include: {
          session: {
            select: {
              sessionId: true,
              title: true,
              status: true
            }
          }
        }
      });

      if (!message) {
        throw new AppError('Message not found', 404);
      }

      return res.status(200).json({
        status: 'success',
        data: message
      });
    } catch (error) {
      next(error);
    }
  }

  async getBatchMessages(req, res, next) {
    try {
      const { sessionId } = req.params;
      const { lastMessageId, limit = 50 } = req.query;

      const whereClause = {
        sessionId,
        ...(lastMessageId && { id: { gt: parseInt(lastMessageId) } })
      };

      const messages = await this.prisma.message.findMany({
        where: whereClause,
        take: parseInt(limit),
        orderBy: {
          createdAt: 'asc'
        },
        include: {
          session: {
            select: {
              sessionId: true,
              title: true,
              status: true
            }
          }
        }
      });

      return res.status(200).json({
        status: 'success',
        results: messages.length,
        data: messages
      });
    } catch (error) {
      next(error);
    }
  }

  async delete(req, res, next) {
    try {
      const { id } = req.params;

      await this.prisma.message.delete({
        where: { id: Number(id) }
      });

      return res.status(204).send();
    } catch (error) {
      next(error);
    }
  }
}
export default MessageController;

================================================================================
Arquivo: ./src/controllers/authController.mjs
================================================================================

// controllers/authController.mjs
import { PrismaClient } from '@prisma/client';
import AppError from '../utils/AppError.mjs';
import { generateToken } from '../utils/generateToken.mjs';
import { comparePasswords } from '../utils/hashPassword.mjs';

class AuthController {
  constructor() {
    this.prisma = new PrismaClient();
    this.login = this.login.bind(this);
    this.logout = this.logout.bind(this);
    this.refreshToken = this.refreshToken.bind(this);
  }

  async login(req, res, next) {
    try {
      const { email, password } = req.body;

      // 1. Verificar se usuário existe
      const user = await this.prisma.user.findUnique({
        where: { email },
        select: {
          id: true,
          email: true,
          password: true,
          username: true,
          phoneNumber: true
        }
      });

      if (!user) {
        throw new AppError('Invalid email or password', 401);
      }

      // 2. Verificar senha
      const isPasswordValid = await comparePasswords(password, user.password);
      if (!isPasswordValid) {
        throw new AppError('Invalid email or password', 401);
      }

      // 3. Gerar token
      const token = generateToken(user.id);

      // 4. Remover senha do objeto de resposta
      const { password: _, ...userWithoutPassword } = user;

      // 5. Criar sessão de login
      await this.prisma.loginSession.create({
        data: {
          userId: user.id,
          token,
          userAgent: req.headers['user-agent'] || 'unknown',
          ipAddress: req.ip
        }
      });

      res.status(200).json({
        status: 'success',
        data: {
          user: userWithoutPassword,
          token
        }
      });
    } catch (err) {
      next(err);
    }
  }

  async logout(req, res, next) {
    try {
      const { token } = req;

      await this.prisma.loginSession.update({
        where: { token },
        data: { isValid: false }
      });

      res.status(204).json({
        status: 'success',
        data: null
      });
    } catch (err) {
      next(err);
    }
  }

  async refreshToken(req, res, next) {
    try {
      const { user } = req;
      const newToken = generateToken(user.id);

      res.status(200).json({
        status: 'success',
        data: {
          token: newToken
        }
      });
    } catch (err) {
      next(err);
    }
  }
}

export default AuthController;

================================================================================
Arquivo: ./src/middlewares/auth.mjs
================================================================================

import jwt from 'jsonwebtoken';
import { PrismaClient } from '@prisma/client';
import AppError from '../utils/AppError.mjs';

const prisma = new PrismaClient();

export const authenticate = async (req, res, next) => {
    try {
        // 1. Pegar o token
        let token;
        if (req.headers.authorization?.startsWith('Bearer')) {
            token = req.headers.authorization.split(' ')[1];
        }

        if (!token) {
            throw new AppError('Not authenticated. Please log in.', 401);
        }

        // 2. Verificar o token
        const decoded = jwt.verify(token, process.env.JWT_SECRET);

        // 3. Verificar se o usuário ainda existe
        const user = await prisma.user.findUnique({
            where: { id: decoded.id },
            select: {
                id: true,
                email: true,
                username: true,
                phoneNumber: true
            }
        });

        if (!user) {
            throw new AppError('User no longer exists.', 401);
        }

        // 4. Colocar o usuário na request
        req.user = user;
        next();
    } catch (error) {
        if (error.name === 'JsonWebTokenError') {
            throw new AppError('Invalid token. Please log in again.', 401);
        }
        if (error.name === 'TokenExpiredError') {
            throw new AppError('Your token has expired. Please log in again.', 401);
        }
        throw error;
    }
};

export const restrictTo = (...roles) => {
    return (req, res, next) => {
        if (!roles.includes(req.user.role)) {
            throw new AppError('You do not have permission to perform this action', 403);
        }
        next();
    };
};

================================================================================
Arquivo: ./src/middlewares/error.mjs
================================================================================

import AppError from '../utils/AppError.mjs';

export const errorHandler = (err, req, res, next) => {
    err.statusCode = err.statusCode || 500;
    err.status = err.status || 'error';

    if (process.env.NODE_ENV === 'development') {
        return res.status(err.statusCode).json({
            status: err.status,
            error: err,
            message: err.message,
            stack: err.stack
        });
    }

    // Erro operacional, erro confiável: enviar mensagem para o cliente
    if (err.isOperational) {
        return res.status(err.statusCode).json({
            status: err.status,
            message: err.message
        });
    }

    // Erro de programação ou outro erro não confiável: não vazar detalhes do erro
    console.error('ERROR 💥', err);
    return res.status(500).json({
        status: 'error',
        message: 'Something went wrong!'
    });
};

// Middleware para lidar com erros assíncronos
export const catchAsync = (fn) => {
    return (req, res, next) => {
        fn(req, res, next).catch(next);
    };
};

// Middleware para rotas não encontradas
export const notFound = (req, res, next) => {
    const err = new AppError(`Can't find ${req.originalUrl} on this server!`, 404);
    next(err);
};

// Handler para erros não tratados (rejeições não tratadas de promessas)
export const handleUncaughtExceptions = () => {
    process.on('uncaughtException', (err) => {
        console.error('UNCAUGHT EXCEPTION! 💥 Shutting down...');
        console.error(err.name, err.message);
        process.exit(1);
    });

    process.on('unhandledRejection', (err) => {
        console.error('UNHANDLED REJECTION! 💥 Shutting down...');
        console.error(err.name, err.message);
        process.exit(1);
    });
};

================================================================================
Arquivo: ./src/middlewares/validate.mjs
================================================================================


// src/middlewares/validate.mjs
import { object, string } from 'yup';
import AppError from '../utils/AppError.mjs';

const auth = {
  login: object({
    body: object({
      email: string().email().required().label('Email'),
      password: string().required().min(6).label('Password')
    })
  })
};

const user = {
  create: object({
    body: object({
      username: string().required().min(3),
      email: string().email().required(),
      password: string().required().min(6),
      phoneNumber: string().required().min(10)
    })
  }),
  update: object({
    body: object({
      username: string().min(3),
      email: string().email(),
      phoneNumber: string().min(10)
    })
  })
};

const session = {
    create: object({
        body: object({
            userId: string().required(),
            title: string().min(3).max(100).optional()
        })
    }),
    update: object({
        body: object({
            title: string().min(3).max(100).required()
        })
    })
};

const message = {
  create: object({
    body: object({
      sessionId: string().required(),
      sender: string().required(),
      content: string().required(),
      phoneNumber: string().required(),
      mediaUrl: string().url().nullable()
    })
  })
};

const vendor = {
  create: object({
    body: object({
      sessionId: string().required(),
      phoneNumber: string().required(),
      vendorName: string().required()
    })
  })
};

const seller = {
  create: object({
    body: object({
      sessionId: string().required(),
      sellerName: string().required(),
      product: string().required(),
      description: string().required(),
      benefits: string().required(),
      image: string().url().nullable()
    })
  })
};

const schemas = {
  auth,
  user,
  session,
  message,
  vendor,
  seller
};

const validate = (schema) => async (req, res, next) => {
  try {
    await schema.validate({
      body: req.body,
      query: req.query,
      params: req.params,
    });
    next();
  } catch (err) {
    throw new AppError(err.message, 400);
  }
};

export { validate, schemas };

================================================================================
Arquivo: ./src/middlewares/rateLimit.mjs
================================================================================

import rateLimit from 'express-rate-limit';
import AppError from '../utils/AppError.mjs';

export const limiter = rateLimit({
    max: 100, // limite de 100 requisições
    windowMs: 60 * 60 * 1000, // 1 hora
    message: 'Too many requests from this IP, please try again in an hour!',
    handler: (req, res) => {
        throw new AppError('Too many requests from this IP, please try again in an hour!', 429);
    }
});

export const authLimiter = rateLimit({
    max: 5, // limite de 5 tentativas
    windowMs: 15 * 60 * 1000, // 15 minutos
    message: 'Too many login attempts from this IP, please try again in 15 minutes!',
    handler: (req, res) => {
        throw new AppError('Too many login attempts from this IP, please try again in 15 minutes!', 429);
    }
});

================================================================================
Arquivo: ./src/routes/sessionRoutes.mjs
================================================================================

// src/routes/sessionRoutes.mjs
import { Router } from 'express';
import SessionController from '../controllers/sessionController.mjs';
import { authenticate } from '../middlewares/auth.mjs';
import { validate, schemas } from '../middlewares/validate.mjs';

const router = Router();
const sessionController = new SessionController();

router
  .route('/')
  .post(
    authenticate,
    validate(schemas.session.create),
    sessionController.create.bind(sessionController)
  )
  .get(
    authenticate,
    sessionController.findAll.bind(sessionController)
  );

router
  .route('/:sessionId')
  .get(
    authenticate,
    sessionController.findOne.bind(sessionController)
  )
  .put(
    authenticate,
    validate(schemas.session.update),
    sessionController.update.bind(sessionController)
  )
  .delete(
    authenticate,
    sessionController.delete.bind(sessionController)
  );

export default router;

================================================================================
Arquivo: ./src/routes/sellerRoutes.mjs
================================================================================

// src/routes/sellerRoutes.mjs
import { Router } from 'express';
import SellerController from '../controllers/sellerController.mjs';
import { authenticate } from '../middlewares/auth.mjs';
import { validate, schemas } from '../middlewares/validate.mjs';

const router = Router();
const sellerController = new SellerController();

router
  .route('/')
  .post(
    authenticate,
    validate(schemas.seller.create),
    sellerController.create.bind(sellerController)
  )
  .get(
    authenticate,
    sellerController.findAll.bind(sellerController)
  );

router
  .route('/:id')
  .get(
    authenticate,
    sellerController.findOne.bind(sellerController)
  )
  .put(
    authenticate,
    sellerController.update.bind(sellerController)
  )
  .delete(
    authenticate,
    sellerController.delete.bind(sellerController)
  );

// Rota adicional para buscar vendedores por sessão
router.get(
  '/session/:sessionId',
  authenticate,
  sellerController.findBySession.bind(sellerController)
);

export default router;

================================================================================
Arquivo: ./src/routes/vendorRoutes.mjs
================================================================================

// src/routes/vendorRoutes.mjs
import { Router } from 'express';
import VendorController from '../controllers/vendorController.mjs';
import { authenticate } from '../middlewares/auth.mjs';
import { validate, schemas } from '../middlewares/validate.mjs';

const router = Router();
const vendorController = new VendorController();

router
  .route('/')
  .post(
    authenticate,
    validate(schemas.vendor.create),
    vendorController.create.bind(vendorController)
  )
  .get(
    authenticate,
    vendorController.findAll.bind(vendorController)
  );

router
  .route('/:id')
  .get(
    authenticate,
    vendorController.findOne.bind(vendorController)
  )
  .put(
    authenticate,
    vendorController.update.bind(vendorController)
  )
  .delete(
    authenticate,
    vendorController.delete.bind(vendorController)
  );

export default router;

================================================================================
Arquivo: ./src/routes/authRoutes.mjs
================================================================================

// routes/authRoutes.mjs
import { Router } from 'express';
import AuthController from '../controllers/authController.mjs';
import { validate, schemas } from '../middlewares/validate.mjs';
import { authenticate } from '../middlewares/auth.mjs';
import { authLimiter } from '../middlewares/rateLimit.mjs';

const router = Router();
const authController = new AuthController();

router.post(
  '/login',
  authLimiter,
  validate(schemas.auth.login),
  authController.login
);

router.post(
  '/logout',
  authenticate,
  authController.logout
);

router.post(
  '/refresh-token',
  authenticate,
  authController.refreshToken
);

export default router;


================================================================================
Arquivo: ./src/routes/userRoutes.mjs
================================================================================

// src/routes/userRoutes.mjs

import { Router } from 'express';
import UserController from '../controllers/userController.mjs';
import { authenticate } from '../middlewares/auth.mjs';
import { authLimiter } from '../middlewares/rateLimit.mjs';

const router = Router();
const userController = new UserController();

// Rota para criar e listar usuários
router
  .route('/')
  .post(
    authLimiter, // Limita tentativas de requisições (proteção contra brute force)
    userController.create // Chama o método de criação no controlador
  )
  .get(
    authenticate, // Requer autenticação
    userController.find // Chama o método de busca de todos os usuários
  );

// Rota para operações específicas por ID de usuário
router
  .route('/:id')
  .get(
    authenticate, // Requer autenticação
    userController.findOne // Chama o método para buscar um usuário específico
  )
  .put(
    authenticate, // Requer autenticação
    userController.update // Chama o método de atualização no controlador
  )
  .delete(
    authenticate, // Requer autenticação
    userController.delete // Chama o método de exclusão no controlador
  );

export default router;


================================================================================
Arquivo: ./src/routes/messageRoutes.mjs
================================================================================

// src/routes/messageRoutes.mjs
import { Router } from 'express';
import MessageController from '../controllers/messageController.mjs';
import { authenticate } from '../middlewares/auth.mjs';
import { validate, schemas } from '../middlewares/validate.mjs';

const router = Router();
const messageController = new MessageController();

router
  .route('/')
  .post(
    authenticate,
    validate(schemas.message.create),
    messageController.create.bind(messageController)
  )
  .get(
    authenticate,
    messageController.findAll.bind(messageController)
  );

router
  .route('/:id')
  .get(
    authenticate,
    messageController.findOne.bind(messageController)
  )
  .delete(
    authenticate,
    messageController.delete.bind(messageController)
  );

// Rota para buscar mensagens em lote de uma sessão específica
router.get(
  '/batch/:sessionId',
  authenticate,
  messageController.getBatchMessages.bind(messageController)
);

export default router;

================================================================================
Arquivo: ./src/routes/sessionsRoutes.mjs
================================================================================

// Importação de módulos
import express from 'express';
import Joi from 'joi';
import qrcode from 'qrcode';
import { PrismaClient } from '@prisma/client';
import { authenticate } from '../middlewares/auth.mjs';
import { createSession } from '../utils/createSession.mjs';

const prisma = new PrismaClient();
const router = express.Router();

// Validação do schema de sessão
const sessionSchema = Joi.object({
  sessionId: Joi.string().required(),
  userId: Joi.number().integer().required(),
});

/**
 * Criar uma nova sessão para um usuário
 */
export const createNewSession = (io, sessions) =>
  router.post('/create', async (req, res) => {
    const { error } = sessionSchema.validate(req.body);
    if (error) return res.status(400).json({ error: error.details[0].message });

    const { sessionId, userId } = req.body;

    try {
      if (!sessionId || !userId) {
        return res.status(400).json({ error: 'sessionId e userId são obrigatórios.' });
      }

      if (sessions[sessionId]) {
        return res.status(400).json({ error: 'Sessão já existe.' });
      }

      const user = await prisma.user.findUnique({ where: { id: userId } });
      if (!user) {
        return res.status(404).json({ error: 'Usuário não encontrado.' });
      }

      // Criar sessão usando a função utilitária
      createSession(sessionId, userId, sessions, io, false);
      res.status(200).json({ message: 'Sessão criada. Aguarde o QR code.' });
    } catch (err) {
      console.error('Erro ao criar sessão:', err);
      res.status(500).json({ error: 'Erro ao criar sessão.', details: err.message });
    }
  });

/**
 * Obter todas as sessões de um usuário
 */
export const getUserSessions = router.get('/user-sessions/:userId', authenticate, async (req, res) => {
  const { userId } = req.params;

  try {
    const userIdParsed = parseInt(userId, 10);
    if (isNaN(userIdParsed)) {
      return res.status(400).json({ error: 'ID de usuário inválido.' });
    }

    const userSessions = await prisma.session.findMany({
      where: { userId: userIdParsed },
    });
    res.status(200).json(userSessions);
  } catch (error) {
    console.error('Erro ao buscar sessões:', error);
    res.status(500).json({ error: 'Erro ao buscar sessões.' });
  }
});

/**
 * Obter QR Code de uma sessão
 */
export const getQrCode = (sessions) =>
  router.get('/get-qr/:sessionId', async (req, res) => {
    const { sessionId } = req.params;

    try {
      if (!sessions[sessionId]) {
        return res.status(404).json({ error: 'Sessão não encontrada.' });
      }

      const { qr, ready } = sessions[sessionId];
      if (ready) {
        return res.status(400).json({ error: 'Sessão já conectada.' });
      }

      if (!qr) {
        return res.status(400).json({ error: 'QR Code ainda não gerado. Tente novamente.' });
      }

      const qrImage = await qrcode.toDataURL(qr);
      res.status(200).json({ qrCode: qrImage });
    } catch (err) {
      console.error('Erro ao gerar QR Code:', err);
      res.status(500).json({ error: 'Erro ao gerar QR Code.', details: err.message });
    }
  });
 


================================================================================
Arquivo: ./src/utils/hashPassword.mjs
================================================================================

// utils/hashPassword.mjs
import bcrypt from 'bcrypt';
import { config } from 'dotenv';
config();

const saltRounds = parseInt(process.env.BCRYPT_ROUNDS);

export const hashPassword = async (password) => {
  return bcrypt.hash(password, saltRounds);
};

export const comparePasswords = async (candidatePassword, hashedPassword) => {
  return bcrypt.compare(candidatePassword, hashedPassword);
};

================================================================================
Arquivo: ./src/utils/validators.js
================================================================================



================================================================================
Arquivo: ./src/utils/buildMessage.js
================================================================================

// Função para construir mensagens para a IA
async function buildMessages(system, prompt, database) {
    return [
      {
        role: "system",
        content: system
      }
      ,
      {
        role: "user",
        content: `Prompt: "${prompt}". Banco de dados: ${JSON.stringify(
          database
        )}.`,
      },
    ];
  }

export default buildMessages;

================================================================================
Arquivo: ./src/utils/AppError.mjs
================================================================================

// src/utils/AppError.mjs
class AppError {
  constructor(message, statusCode = 400, errors = []) {
    this.message = message;
    this.statusCode = statusCode;
    this.status = `${statusCode}`.startsWith('4') ? 'error' : 'fail';
    this.isOperational = true;
    this.errors = errors; // Inclui detalhes dos erros

    Error.captureStackTrace(this, this.constructor);
  }
}
export default AppError;

================================================================================
Arquivo: ./src/utils/generateToken.mjs
================================================================================

// utils/generateToken.mjs
import jwt from 'jsonwebtoken';
import { config } from 'dotenv';
config();

export const generateToken = (userId) => {
  return jwt.sign(
    { id: userId },
    process.env.JWT_SECRET,
    { expiresIn: process.env.JWT_EXPIRES_IN }
  );
};

================================================================================
Arquivo: ./src/utils/createSession.mjs
================================================================================

// Importações
import pkg from 'whatsapp-web.js';
const { Client, LocalAuth } = pkg;
import personAI from "../core/person.mjs";


import Tools from './tools.mjs';
import { PrismaClient } from '@prisma/client';
import { Server } from 'socket.io';

// Inicializações
const tools = new Tools();
const prisma = new PrismaClient();

/**
 * Cria e gerencia uma sessão do WhatsApp
 * @param {string} sessionId - ID único da sessão
 * @param {string} userId - ID do usuário associado
 * @param {Object} sessions - Objeto contendo as sessões ativas
 * @param {Server} io - Instância do Socket.IO para comunicação
 */
export async function createSession(sessionId, userId, sessions, io) {
    const client = new Client({
        authStrategy: new LocalAuth({ clientId: sessionId }),
    });

    // Evento de QR Code gerado
    client.on('qr', async (qr) => {
        console.log(`QR code gerado para a sessão ${sessionId}`);
        sessions[sessionId] = { ...sessions[sessionId], qr };
        io.emit(`qr-${sessionId}`, qr);
    });

    // Evento quando o cliente está pronto
    client.on('ready', async () => {
        console.log(`Cliente ${sessionId} está pronto!`);
        sessions[sessionId] = { ...sessions[sessionId], ready: true };

        try {
            await prisma.session.upsert({
                where: { sessionId },
                update: { createdAt: new Date() },
                create: { sessionId, userId },
            });
            io.emit(`ready-${sessionId}`);
        } catch (error) {
            console.error(`Erro ao salvar a sessão ${sessionId} no banco de dados:`, error);
        }
    });

    // Evento para mensagens recebidas
    client.on('message', async (message) => {
        if (message.fromMe) return;

        const userId = message.from;
        if (userId.includes('status')) return; // Ignora mensagens de status

        try {
            let resposta;

            if (message.hasMedia) {
                const mediaData = await tools.baixarMidia(message);
                resposta = mediaData
                    ? await tools.processarMedia(userId, mediaData, sessionId)
                    : "Não consegui baixar a mídia.";
            } else {
                resposta = await tools.processarTexto(userId, message.body, sessionId);
            }

            if (resposta) {
                await message.reply(resposta.replace(/\*\*/g, '*'));
            }
        } catch (error) {
            console.error(`Erro ao processar mensagem para o usuário ${userId}:`, error);
        }
    });

    // Evento quando o cliente é desconectado
    client.on('disconnected', () => {
        console.log(`Cliente ${sessionId} desconectado.`); 
        io.emit(`disconnected-${sessionId}`);
    });

    // Inicialização do cliente
    try {
        await client.initialize();
        sessions[sessionId] = { client, qr: null, ready: false };
    } catch (error) {
        console.error(`Erro ao inicializar o cliente para a sessão ${sessionId}:`, error);
        delete sessions[sessionId];
    }
}


================================================================================
Arquivo: ./src/utils/tools.mjs
================================================================================

import Cerebro from '../cerebro.mjs';

const cerebro = new Cerebro();

class Tools {
  constructor() {}
  // Processa o texto enviado pelo usuário
  async processarTexto(userId, mensagemUsuario, sessionId) {
    return await cerebro.gerarRespostaIA(userId, mensagemUsuario, sessionId);
  }

  // Processa mídias enviadas pelo usuário
  async processarMedia(userId, mediaData, sessionId) {
    if (mediaData.mimetype.startsWith('image')) {
      return await cerebro.gerarRespostaImagem(userId, mediaData);
    } else if (mediaData.mimetype.startsWith('audio')) {
      return await cerebro.transcreverAudio(userId, mediaData, sessionId);
    }
    return 'Tipo de mídia não suportado.';
  }

  // Baixa a mídia recebida na mensagem
  async baixarMidia(message) {
    try {
      const media = await message.downloadMedia();
      return media ? {
        mimetype: media.mimetype,
        data: `data:${media.mimetype};base64,${media.data}`,
      } : null;
    } catch (error) {
      console.error('Erro ao baixar a mídia:', error);
      return { error: 'Falha ao baixar a mídia.' };
    }
  }
}

export default Tools;

 

================================================================================
Arquivo: ./src/utils/initSession.mjs
================================================================================

// Importações
import { PrismaClient } from '@prisma/client';
import { createSession } from './createSession.mjs';

// Inicialização do Prisma
const prisma = new PrismaClient();

/**
 * Inicializa todas as sessões salvas no banco de dados
 * @param {Object} sessions - Objeto que armazena sessões ativas
 * @param {import('socket.io').Server} io - Instância do Socket.IO
 */
async function initSessions(sessions, io) {
    try {
        // Buscando todas as sessões no banco de dados
        const sessionsFromDB = await prisma.session.findMany();

        // Iterando sobre as sessões e recriando-as
        sessionsFromDB.forEach(session => {
            createSession(session.sessionId, session.userId, sessions, io, true);
        });
    } catch (error) {
        console.error("Erro ao buscar sessões:", error);
    }
}
export default initSessions;

================================================================================
Arquivo: ./src/utils/vendorSearch.mjs
================================================================================

import logger from "../log/logger.mjs";

class SellerService {
  constructor(prismaClient) {
    this.prisma = prismaClient;
  }

  /**
   * Busca vendedores com base nos parâmetros fornecidos.
   * @param {Object} options - Parâmetros de busca.
   * @param {string} options.sessionId - Identificador da sessão.
   * @param {string} [options.sellerName] - Nome do vendedor (opcional).
   * @param {string} [options.product] - Nome do produto (opcional).
   * @param {string} [options.returnType="sellers"] - Tipo de retorno desejado ("sellers" ou "results").
   * @returns {Object} Resultado da busca.
   */
  async findSellers({ sessionId, sellerName, product, returnType = "sellers" }) {
    try {
      let results = [];

      // Busca por nome do vendedor
      if (sellerName) {
        results = await this.prisma.seller.findMany({
          where: {
            sessionId,
            sellerName: {
              contains: sellerName,
              mode: "insensitive",
            },
          },
        });
      }

      // Busca por produto, caso não tenha resultados por nome
      if (results.length === 0 && product) {
        results = await this.prisma.seller.findMany({
          where: {
            sessionId,
            product: {
              contains: product,
              mode: "insensitive",
            },
          },
        });
      }

      // Caso ainda não haja resultados, busca todos os vendedores da sessão
      if (results.length === 0) {
        results = await this.prisma.seller.findMany({
          where: { sessionId },
        });
      }

      // Decisão sobre o tipo de retorno
      if (returnType === "sellers") {
        // Mapeia os resultados para a estrutura desejada
        const sellers = results.map(({ sellerName, product }) => ({
          sellerName,
          product,
        }));

        return { sellers };
      }

      // Retorna os resultados completos se o tipo for "results"
      return { results };
    } catch (error) {
      logger.error("Erro ao buscar vendedores no banco de dados:", error);
      throw new Error("Erro interno ao acessar o banco de dados.");
    }
  }

  /**
   * Busca o vendedor mais recente para uma sessionId.
   * @param {Object} options - Parâmetros de busca.
   * @param {string} options.sessionId - Identificador da sessão.
   * @param {string} [options.returnType="sellers"] - Tipo de retorno desejado ("sellers" ou "results").
   * @returns {Object} Vendedor mais recente.
   */
  async findMostRecentSeller({ sessionId, returnType = "seller" }) {
    try {
      const recentSeller = await this.prisma.seller.findFirst({
        where: { sessionId },
        orderBy: { createdAt: 'desc' },  // Ordena pela data de criação em ordem decrescente
      });

      if (!recentSeller) {
        return { seller: null };
      }

      // Decide o tipo de retorno baseado no parâmetro returnType
      if (returnType === "seller") {
        const { sellerName, product } = recentSeller;
        return { seller: [{ sellerName, product }] };
      }

      // Retorna o resultado completo se o tipo for "results"
      return { seller: recentSeller };
    } catch (error) {
      logger.error("Erro ao buscar vendedor mais recente no banco de dados:", error);
      throw new Error("Erro interno ao acessar o banco de dados.");
    }
  }
}

export default SellerService;


================================================================================
Arquivo: ./src/services/userService.mjs
================================================================================

import prisma from '@prisma/client';
import bcrypt from 'bcrypt';
import AppError from '../utils/AppError.mjs';

import { PrismaClient } from '@prisma/client';

class UserService {
    constructor() {
        this.prisma = new PrismaClient();
    }

    async create(userData) {
        const { username, email, password, phoneNumber } = userData;

        console.log('Validating user data...');
        const userExists = await this.prisma.user.findFirst({
            where: {
                OR: [
                    { email },
                    { username },
                    { phoneNumber }
                ]
            }
        });

        if (userExists) {
            console.error('User already exists:', userExists);
            throw new AppError('User already exists', 400);
        }

        console.log('Hashing password...');
        const hashedPassword = await bcrypt.hash(password, 10);

        console.log('Creating user in the database...');
        const user = await this.prisma.user.create({
            data: {
                username,
                email,
                password: hashedPassword,
                phoneNumber
            },
            select: {
                id: true,
                username: true,
                email: true,
                phoneNumber: true,
                createdAt: true
            }
        });

        console.log('User created successfully:', user);
        return user;
    }

    async findAll() {
        console.log('Fetching all users...');
        return this.prisma.user.findMany({
            select: {
                id: true,
                username: true,
                email: true,
                phoneNumber: true,
                createdAt: true
            }
        });
    }

    async findById(id) {
        console.log(`Fetching user with ID: ${id}`);
        const user = await this.prisma.user.findUnique({
            where: { id: Number(id) },
            select: {
                id: true,
                username: true,
                email: true,
                phoneNumber: true,
                createdAt: true
            }
        });

        if (!user) {
            console.error('User not found:', id);
            throw new AppError('User not found', 404);
        }

        return user;
    }

    async update(id, userData) {
        console.log(`Updating user with ID: ${id}`);
        await this.findById(id);

        const updatedUser = await this.prisma.user.update({
            where: { id: Number(id) },
            data: userData,
            select: {
                id: true,
                username: true,
                email: true,
                phoneNumber: true,
                createdAt: true
            }
        });

        console.log('User updated successfully:', updatedUser);
        return updatedUser;
    }

    async delete(id) {
        console.log(`Deleting user with ID: ${id}`);
        await this.findById(id);

        await this.prisma.user.delete({
            where: { id: Number(id) }
        });

        console.log('User deleted successfully.');
    }
}

export default UserService;

================================================================================
Arquivo: ./src/services/sellerService.mjs
================================================================================

import { PrismaClient } from '@prisma/client';

const prisma = new PrismaClient();

export default class Seller {
    constructor() {
        this.prisma = prisma;
    }

    // Criar vendedor
    async create({ sessionId, sellerName, product, description, benefits, image = null }) {
        try {
            // Validação simples dos dados antes de criar o vendedor
            if (!sellerName || !sessionId || !product || !description || !benefits) {
                return {
                    success: false,
                    message: 'Todos os campos obrigatórios devem ser preenchidos.',
                };
            }

            const seller = await this.prisma.seller.create({
                data: {
                    sessionId,
                    sellerName,
                    product,
                    description,
                    benefits,
                    image: image ?? null,
                },
            });
            return { success: true, message: 'Vendedor criado com sucesso!', seller };
        } catch (error) {
            if (error.code === 'P2002') {
                // Erro P2002 é retornado quando uma restrição de unicidade é violada
                return {
                    success: false,
                    message: `O vendedor "${sellerName}" já está registrado nesta sessão.`,
                };
            }
            console.error("Erro ao criar vendedor:", error);
            throw new Error('Erro ao criar vendedor');
        }
    }

    // Buscar todos os vendedores de uma sessão
    async findSeller(sessionId) {
        try {
            const sellers = await this.prisma.seller.findMany({
                where: { sessionId },
                orderBy: { createdAt: 'asc' },
            });
            return sellers;
        } catch (error) {
            console.error("Erro ao buscar vendedores:", error);
            throw new Error('Erro ao buscar vendedores');
        }
    }

    // Buscar vendedor por nome em uma sessão (retorna o primeiro encontrado)
    async findSellerByName(sessionId, sellerName) {
        try {
            const seller = await this.prisma.seller.findFirst({
                where: {
                    sessionId,
                    sellerName: {
                        contains: sellerName,
                        mode: 'insensitive',
                    },
                },
            });
            return seller;
        } catch (error) {
            console.error("Erro ao buscar vendedor por nome:", error);
            throw new Error('Erro ao buscar vendedor por nome');
        }
    }
}



================================================================================
Arquivo: ./src/core/person.mjs
================================================================================

import sellerJSON from "./getSeller.mjs";
import SellerService from "../utils/vendorSearch.mjs";
import { PrismaClient } from "@prisma/client";
import dotenv from "dotenv";
import { ChatGroq } from "@langchain/groq";
import { ChatPromptTemplate } from "@langchain/core/prompts";
import MessageService from "./messageService.js";
import VendorService from "./vendorService.js"; 

// Carregar variáveis de ambiente do arquivo .env
dotenv.config();

// Inicializa o Prisma Client
const prisma = new PrismaClient();
const sellerService = new SellerService(prisma);
const vendorService = new VendorService(prisma);
const messageService = new MessageService();

// Função: Gerar Features e Público-Alvo
async function personAI(vendorId, mensagem, phoneNumber) {
  try {
    console.log("Iniciando busca de vendedores no banco de dados...");
    const database = await sellerService.findSellers({
      sessionId: vendorId,
      sellerName: null,
      product: null,
      returnType: "sellers",
    });
    console.log("Dados do banco de dados retornados:", database);

    const data = await sellerJSON(mensagem, database);

    let vendorName = data?.matched?.sellerName || null;
    const sellerProduct = data?.matched?.product || null;
    console.log("Dados processados do cliente:", data);

    // Verifica se o vendedor existe
    const exists = await vendorService.checkVendorExists(vendorId, phoneNumber);

    // Atualiza ou cria o vendedor com base nos dados
    if (exists && vendorName) {
      console.log(`Atualizando nome do vendedor para: ${vendorName}`);
      await vendorService.updateVendorName(vendorId, vendorName);
    } else if (vendorName && phoneNumber && vendorId) {
      console.log("Criando novo vendedor...");
      console.log("Dados do vendedor:", { vendorId, phoneNumber, vendorName });
      await vendorService.createVendor(vendorId, phoneNumber=phoneNumber, vendorName);

      console.error("Os campos obrigatórios estão ausentes. Dados recebidos:");
      console.error({ vendorId, phoneNumber, vendorName });
      throw new Error("Dados insuficientes para criar o vendedor.");
    }

    const vendorData = await vendorService.findVendorsBySession(vendorId, phoneNumber);
    console.log("Dados do Vendedor:", vendorData);
    
    vendorName = vendorData && vendorData.length > 0 && !vendorName?vendorData.forEach(vendor => {vendor.vendorName }) : null;
    

    // Decide qual método usar para buscar os dados
    const alldata = !vendorName && !sellerProduct
      ?  await sellerService.findMostRecentSeller(vendorId) : await sellerService.findSellers({
          sessionId: vendorId,
          sellerName: vendorName,
          product: sellerProduct,
          returnType: "results",
        });

    // Verifica se há resultados
    const [firstResult] = alldata?.results || alldata?.seller;
    if (!firstResult) {
      console.error("Nenhum resultado encontrado em alldata.results.");
      return "Nenhum vendedor ou produto foi encontrado no banco de dados.";
    }

    const {
      id,
      sessionId,
      sellerName,
      product,
      description,
      image,
      benefits,
      createdAt,
    } = firstResult;

    const db = `Banco de dados:
    ID: ${id};
    Session ID: ${sessionId};
    Seller Name: ${sellerName};
    Product: ${product};
    Description: ${description};
    Image: ${image || "Nenhuma imagem disponível"};
    Benefits: ${benefits};
    Created At: ${createdAt};
    `;

    // Inicializa o modelo de linguagem e processa o prompt
    const llm = new ChatGroq({
      model: "llama3-groq-70b-8192-tool-use-preview",
      temperature: 0.7,
      maxRetries: 2,
      apiKey: process.env.GROQ_API_KEY,
    });

    const prompt = ChatPromptTemplate.fromMessages([
      [
        "system",
        "Você é um vendedor inteligente que assume a personalidade do vendedor responsável pelo produto mencionado pelo cliente. Ao identificar um produto ou vendedor no banco de dados, você adapta seu estilo de comunicação para refletir o comportamento e tom do vendedor associado. Responda de maneira amigável, personalizada e persuasiva, ajudando o cliente a tomar a melhor decisão. Aprimore o marketing: Adicione gatilhos como vantagens adicionais na mensagem.Inclua instruções simples de como finalizar a compra diretamente.",
      ],
      ["human", "Prompt do cliente: {prompt}. Banco de dados disponível: {database}."],
    ]);

    const chain = prompt.pipe(llm);

    const response = await chain.invoke({
      prompt: mensagem,
      database: db,
    });
    try{
    	await messageService.registerMessage(
    	sessionId=vendorId, 
    	sender="Client",
    	content=mensagem,
    	mediaUrl=null,
    	phoneNumber=phoneNumber
    	);
    	await messageService.registerMessage(
    	sessionId=vendorId, 
    	sender="AI",
    	content=response.content,
    	mediaUrl=null,
    	phoneNumber=phoneNumber
    	);
    	
    	console.log("Mensagens salvas com sucesso!")
    }catch(error){
    	console.log("Erro ao salvar mensagens: ", error)
    }

    return response.content; // Retorna o texto com features e público-alvo
    
  } catch (error) {
    console.error("Erro ao executar a função personAI:", error);
    return "Ocorreu um erro ao processar sua solicitação. Tente novamente mais tarde.";
  }
}

export default personAI;


================================================================================
Arquivo: ./src/core/messageService.js
================================================================================

import { PrismaClient } from '@prisma/client';

class MessageService {
  constructor() {
    this.prisma = new PrismaClient();
  }

  // Função para registrar uma nova mensagem
  async registerMessage({ sessionId, sender, content, mediaUrl, phoneNumber }) {
    try {
      await this.prisma.message.create({
        data: {
          sessionId,
          sender,
          content,
          mediaUrl: mediaUrl || null,
          phoneNumber,
        },
      });
      console.info('Mensagem registrada!'); 
    } catch (error) {
      console.error('Erro ao registrar mensagem:', error);
      throw error;
    }
  }

  // Função para filtrar mensagens por sessionId e phoneNumber
  async filterMessagesBySessionAndPhone(sessionId, phoneNumber) {
    try {
      const messages = await this.prisma.message.findMany({
        where: {
          sessionId,
          phoneNumber,
        },
      });
      console.log('Mensagens filtradas:', messages);
      return messages;
    } catch (error) {
      console.error('Erro ao filtrar mensagens:', error);
      throw error;
    }
  }

  // Método para desconectar o Prisma Client (opcional, usado em scripts)
  async disconnect() {
    await this.prisma.$disconnect();
  }
}

export default MessageService;


================================================================================
Arquivo: ./src/core/getSeller.mjs
================================================================================

import { ChatGroq } from '@langchain/groq'; 
import dotenv from 'dotenv'; 

import buildMessages from '../utils/buildMessage.js';  
 
// Carregar variáveis de ambiente do arquivo .env
dotenv.config();

// Configuração do modelo
const llm = new ChatGroq({
  model: "mixtral-8x7b-32768",
  temperature: 0,
  maxTokens: undefined,
  maxRetries: 2,
  apiKey: process.env.GROQ_API_KEY,
});

async function sellerJSON(userPrompt, database) {
  const system =
    "Você é um analisador de texto que verifica se o prompt do usuário contém nomes de vendedores ou produtos presentes no banco de dados. Caso encontre correspondência apenas no produto, deve adicionar no seu JSON o nome do vendedor do banco de dados. Retorne o resultado em JSON no formato: { found: boolean, matched: { sellerName: string | null, product: string | null } }.";

  try {
    // Construção das mensagens
    const mensagens = await buildMessages(system, userPrompt, database);

    // Vincular o formato de resposta
    const llmComFormatoResposta = llm.bind({
      response_format: { type: "json_object" },
    });

    // Chamada ao modelo
    const mensagemVinculadaIA = await llmComFormatoResposta.invoke(mensagens);

    // Analise o conteúdo como JSON
    const data = JSON.parse(mensagemVinculadaIA.content);
    

    return data;
  } catch (error) {
    console.error("Erro ao executar o modelo:", error);
    return null; // Retorne null em caso de erro
  }
}

export default sellerJSON;

 


================================================================================
Arquivo: ./src/core/vendorService.js
================================================================================

import { PrismaClient } from '@prisma/client';

class VendorService {
  constructor() {
    this.prisma = new PrismaClient();
  }

  // Atualizar nome do vendedor
  async updateVendorName(vendorId, newName) {
    try {
      // Encontre o vendedor com o sessionId
    const vendor = await this.prisma.vendor.findFirst({
      where: {sessionId: vendorId },
    });

    if (!vendor) {
      throw new Error("Vendedor não encontrado.");
    }

      await this.prisma.vendor.update({
        where: { id: vendor.id },
        data: {
          vendorName: newName, // Atualiza o nome do vendedor
        },
      });
      console.info('Nome do vendedor atualizado!'); 
    } catch (error) {
      console.error('Erro ao atualizar o nome do vendedor:', error);
      throw error;
    }
  }

  // Criar um novo vendedor
  async createVendor(vendorId, phoneNumber, vendorName) {
    console.log("Dados do vendedor:", { vendorId, phoneNumber, vendorName }); 
  
    try {
      await this.prisma.vendor.create({
        data: {
          sessionId: vendorId,
          phoneNumber,
          vendorName,
        },
      });
      console.info('Vendedor criado com sucesso:', vendorName);
    } catch (error) {
      console.error('Erro ao criar vendedor:', error);
      throw error;
    }
  }
  
  
  

  // Buscar vendedores por sessionId
  async findVendorsBySession(sessionId, phoneNumber) {
    try {
      const vendors = await this.prisma.vendor.findMany({
        where: {
          sessionId,
          phoneNumber,
        },
      });
      console.info('Vendedor encontrado!',);
      return vendors;
    } catch (error) {
      console.error('Erro ao buscar vendedor!', error);
      throw error;
    }
  }

  // Verificar se existe um vendedor na sessão com o número de telefone
  async checkVendorExists(sessionId, phoneNumber) {
    try {
      const existingVendor = await this.prisma.vendor.findFirst({
        where: {
          sessionId,
          phoneNumber,
        },
      });
      return !!existingVendor; // Retorna true se encontrar, false caso contrário
    } catch (error) {
      console.error('Erro ao verificar vendedor:', error);
      throw error;
    }
  } 
  
  // Desconectar o Prisma Client
  async disconnect() {
    await this.prisma.$disconnect();
  }
}

export default VendorService;


================================================================================
Arquivo: ./src/log/logger.mjs
================================================================================

import winston from "winston";

const logger = winston.createLogger({
  level: "info",
  format: winston.format.combine(
    winston.format.colorize(),
    winston.format.printf(({ level, message }) => `${level}: ${message}`)
  ),
  transports: [new winston.transports.Console()],
});

export default logger;




SCHEMAS PRISMA
================================================================================
Diretório base: ./prisma
================================================================================

================================================================================
Arquivo: ./prisma/schema.prisma
================================================================================

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id          Int       @id @default(autoincrement())
  username    String    @unique
  email       String    @unique
  password    String
  phoneNumber String    @unique
  createdAt   DateTime  @default(now())
  sessions    Session[]
  loginSessions LoginSession[]
}

model LoginSession {
  id        Int      @id @default(autoincrement())
  userId    Int
  token     String   @unique
  userAgent String
  ipAddress String
  isValid   Boolean  @default(true)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
}
model Session {
  id        Int       @id @default(autoincrement())
  sessionId String    @unique
  title     String?
  type      String?   @default("regular")
  status    String?   @default("active")
  userId    Int
  createdAt DateTime  @default(now())
  messages  Message[]
  seller    Seller[]
  user      User      @relation(fields: [userId], references: [id])
  vendors   Vendor[]
}


model Message {
  id          Int      @id @default(autoincrement())
  sessionId   String
  sender      String
  content     String
  mediaUrl    String?
  createdAt   DateTime @default(now())
  phoneNumber String
  session     Session  @relation(fields: [sessionId], references: [sessionId])
}

model Vendor {
  id          Int      @id @default(autoincrement())
  sessionId   String   @unique
  phoneNumber String
  vendorName  String
  createdAt   DateTime @default(now())
  session     Session  @relation(fields: [sessionId], references: [sessionId])
}

model Seller {
  id          Int      @id @default(autoincrement())
  sessionId   String
  sellerName  String
  product     String
  description String
  image       String?
  benefits    String
  createdAt   DateTime @default(now())
  session     Session  @relation(fields: [sessionId], references: [sessionId])

  @@unique([sessionId, sellerName])
}

